---
defaults:
  - scope:
      path: ""
      type: posts
    values:
      layout: single
      author_profile: true
      comments: true
      share: true
      related: true

title: "Spring Core Basic(1)"
excerpt: "스프링 핵심 기본(1)"
toc: true
toc_sticky: true
toc_label: "목차"
categories:
  - Spring
tags:
  - [Spring, 김영한, 스프링 핵심 기본]
date: 2021-07-27
last_modified_at: 2021-07-27
---

## 스프링의 탄생 배경

옛날에는 자바 진영에서 EJB (Enterprise Java Beans) 가 정파의 기술로 여겨졌다.

안정적인 기술로 여겨져서 기술 영업도 잘되었고 오픈 소스는 안정성 문제 때문에 도입이 안되던 시절이었다.

EJB는 트랜잭션, 분산 서버, Entity Bean이라는 ORM 기술을 가지고 있었다. (나름 장점이 많았다)

하지만 비용이 너무 비쌌을 뿐더러 (서버 한대에 수천만원?) 너무 어렵고 복잡했다.

너무 EJB 의존적으로 개발하다보면 코드 또한 지저분해지고 복잡해졌다... 😢😫

무엇보다 객체지향이 가진 좋은 장점을 다 잃어버리게 되었다.

그러다보니 POJO(Plain Old Java Object) 라는 구호가 나오기 시작했는데 오래된 방식의 간단한 자바 오브젝트라는 말이다. 한마디로 순수 과거 자바 스타일로 돌아가자는 뜻이었다. EJB라는 무거운 프레임워크에 종속된 무거운 객체를 만들게 된 것에 개발자들이 반발해서 사용하게 된 용어이다.

결국 Gavin King이라는 사람이 하이버네이트라는 오픈 소스를 만들기 시작했다.

하이버네이트는 EJB 엔티티빈 기술을 대체하였고 JPA(Java Persistence API) 의 새로운 표준을 정의하였다. 

JPA는 표준 인터페이스이고 이것을 구현한 하이버네이트, EclipseLink 등의 벤더들이 있다.

현재 자바 ORM 시장은 거의 JPA가 차지하고 있고 JPA 구현체 중에서도 하이버네이트가 주로 쓰인다.

Rod Johnson이 EJB 를 대체하자는 책을 출간한 이후 Juergen Hoeller(유겐 휠러), Yann Caroff(얀 카로프)가 Rod Johnson에게 오픈 소스프로젝트를 제안하였다.

결국 Rod Johnson 이라는 사람이 EJB 컨테이너를 대체할 스프링 오픈소스를 만들기 시작했다.

스프링의 핵심 코드의 상당수는 Juergen Hoeller가 개발하고 있고 지금도 현재진행형이다.

스프링의 이름은 전통적인 EJB(J2EE)라는 겨울을 넘어 새로운 시작이라는 뜻이다.



## 스프링 버전별 특징

- 2003년 스프링 프레임워크 1.0 출시 - XML (당시 대세)
- 2006년 스프링 프레임워크 2.0 출시 - XML 편의 기능 지원
- 2009년 스프링 프레임워크 3.0 출시 - 자바 코드로 설정(XML 없이)
- 2013년 스프링 프레임워크 4.0 출시 - 자바 8 지원
- 2014년 스프링 부트 1.0 출시 - 설정이 너무 간편해졌고 서버 내장방식을 택함
- 2017년 스프링 프레임워크 5.0 출시, 스프링 부트 2.0 출시 - 리액티브 프로그래밍 지원(비동기 non-blocking 지원 - Node.js처럼)
- 2021년 7월 현재 스프링 프레임워크 5.3.9, 스프링 부트 2.5.3

## 스프링이란?

스프링이란 여러가지 기술의 모음이다.

- 스프링 프레임워크
  - 핵심 기술: 스프링 DI 컨테이너, AOP, 이벤트, 기타
  - 웹 기술: 스프링 MVC, 스프링 WebFlux
  - 데이터 접근 기술: 트랜잭션, JDBC, ORM 지원, XML 지원
  - 기술 통합: 캐시, 이메일, 원격접근, 스케줄링
  - 테스트: 스프링 기반 테스트 지원
  - 언어: 코틀린, 그루비
- 스프링 부트
  - 스프링을 편리하게 사용할 수 있도록 지원, 최근에는 기본
  - 단독으로 실행할 수 있는 스프링 애플리케이션을 쉽게 생성
  - Tomcat 같은 웹 서버를 내장해서 별도의 웹 서버를 설치하지 않아도 됨
  - 손쉬운 빌드 구성을 위한 starter 종속성 제공
  - 스프링과 외부(3rt part) 라이브러리 자동 구성
  - 메트릭, 상태 확인, 외부 구성 같은 프로덕션 준비 기능 제공
  - 관례에 의한 간결한 설정
- 스프링 데이터 (crud를 편리하게 사용할 수 있게 도와주는 것)
- 스프링 세션 (세션 기능을 편하게 사용하게 해주는 것)
- 스프링 시큐리티 (보안과 관련된 것)
- 스프링 Rest Docs (API 문서랑 테스트를 편하게 엮어서 API 문서를 편리하게 해주는 것)
- 스프링 배치 (배치처리에 특화된 기술)
- 스프링 클라우드 (클라우드에 특화된 기술)

스프링이란 단어는 문맥에 따라 다르게 사용된다.

- 스프링 DI 컨테이너 기술 (ex 소스코드 상에서 스프링 컨테이너라고 언급할 때)
- 스프링 프레임워크
- 스프링 부트, 스프링 프레임워크 등을 모두 포함한 스프링 생태계

### 스프링의 진짜 핵심

- 스프링은 객체지향 언어인 자바 기반의 프레임워크
- 스프링은 객체 지향 언어가 가진 강력한 특징을 살려내는 프레임워크
- 스프링은 좋은 객체 지향 애플리케이션을 개발할 수 있게 도와주는 프레임워크



## 객체 지향 프로그래밍

- 객체 지향 프로그래밍은 컴퓨터 프로그램을 명령어의 목록으로 보는 시각에서 벗어나 여러 개의 독립된 단위, 즉 '객체'들의 모임으로 파악하고자 하는 것이다. 각각의 객체는 메시지를 주고받고, 데이터를 처리할 수 있다. (협력)
- 객체 지향 프로그래밍은 프로그램을 유연하고 변경이 용이하게 만들기 때문에 대규모 소프트웨어 개발에 많이 사용된다.

### 다형성의 본질

- 인터페이스를 구현한 객체 인스턴스를 실행 시점에 유연하게 변경할 수 있다.
- 다형성의 본질을 이해하려면 협력이라는 객체사이의 관계에서 시작해야한다.
- 클라이언트를 변경하지 않고, 서버의 구현 기능을 유연하게 변경할 수 있다.
- 스프링에서 이야기하는 IOC(제어의 역전), DI(의존관계 주입)은 다형성을 활용해서 역할과 구현을 편리하게 다룰 수 있도록 지원한다.

### 역할과 구현을 분리

- 실세계의 역할과 구현이라는 편리한 개념을 다형성을 통해 가져올 수 있다.
- 유연하고, 변경이 용이하며 확장 가능한 설계이다.
- 클라이언트에 영향을 주지 않고 변경이 가능하다.
- 인터페이스를 안정적으로 잘 설계하는 것이 중요하다. (인터페이스 자체의 변경은 파급효과가 크다.)

### SOLID 원칙

- SRP 단일 책임 원칙 (Single responsibility principle)
  - 한 클래스는 하나의 책임만 가져야 한다는 뜻인데, 이 기준은 모호하다.
  - 중요한 기준은 변경이다. 변경이 있을 때 파급 효과가 적으면 단일 책임 원칙을 잘 따른 것이다.
  - ex) UI 변경으로 sql코드부터 애플리케이션 코드를 다 고치면 SRP 원칙에 어긋난 것이다.
  - ex) 객체의 생성과 사용을 분리하도록 하자.

- OCP 개방 폐쇄 원칙 (Open Closed Principle)
  - 확장에는 열려 있으나 변경에는 닫혀 있어야 한다.
  - 다형성을 활용한다.
  - 인터페이스를 구현한 새로운 클래스를 만듬으로써 새로운 기능을 추가한다(확장)
  - 객체를 생성하고, 연관관계를 맺어주는 별도의 조립, 설정자가 필요하다.(스프링 컨테이너가 이 역할을 한다!)
- LSP 리스코프 치환 원칙 (Liskov Substitution Principle)
  - 객체는 하위 타입의 인스턴스로 바꾸더라도 프로그램 동작에 문제가 없어야 한다.
  - 다형성을 지원하기 위한 원칙으로, 하위 클래스가 인터페이스 규약을 다 지키도록 하여 구현체를 신뢰할 수 있게 한다.
- ISP 인터페이스 분리원칙 (Interface Segregation Principle)
  - 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다.
  - 인터페이스의 역할이 명확해지고, 대체하기 쉬워진다.
- DIP 의존관계 역전 원칙 (Dependency Inversion Principle)
  - 구체화(구현 클래스)에 의존하면 안되고, 추상화(인터페이스)에 의존해야 한다.
  - 다시 말해 역할에 의존하게 해야 한다는 뜻이다.
  - 구현체에 의존하게 되면 변경이 아주 어려워진다.

```java
public class MemberService  {
    private MemberRepository memberRepository = new MemoryMemberRepository();
}
```

이와 같은 코드는 MemberService가 인터페이스인 MemberRepository 뿐 아니라 구현체인 MemoryMemberRepository까지 의존하고 있기에 DIP 원칙을 위반한다. 그래서 구현체를 변경하려고 하면 OCP 원칙을 위반하게 된다.

즉, 객체 지향의 핵심이 다향성이지만, 다형성만으로는 OCP와 DIP를 지킬 수 없게 된다.

그래서 스프링에서는 

- DI(Dependency Injection)
- DI 컨테이너 (객체들을 넣어놓고 의존 관계를 서로 연결해주고 주입해주는 기술)

를 제공해준다.

> 이상적으로는  모든 설계에 인터페이스를 부여하는 것이 좋지만, 추상화라는 개발자의 노력 비용이 들어간다.
>
> 즉,  구체 구현 클래스가 무엇인지 코드를 한번더 살펴봐야 한다.
>
> 김영한 선생님은 변경 가능성이 없는 것은 바로 구체 클래스를 직접 사용하고, 향후 꼭 필요할 때 리팩토링을 통해 인터페이스를 도입하는 것을 추천하신다.

## Reference

이 글은 김영한님의 [스프링 핵심 원리 - 기본편](https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8/dashboard)을 보고 정리하였습니다.

