---
defaults:
- scope:
  path: ""
  type: posts
  values:
  layout: single
  author_profile: true
  comments: true
  related: true

title: "[SWEA] 벽돌깨기"
excerpt: "[SWEA] 벽돌깨기"
toc: true
toc_sticky: true
toc_label: "목차"
categories:
  - Coding Test 
tags:
  - [Coding Test, SWEA, 구현, DFS]
date: 2021-10-08
last_modified_at: 2021-10-08
---
# [SWEA] 벽돌깨기

Problem URL : [벽돌깨기](https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AWXRQm6qfL0DFAUo)

```cpp
#include<iostream>
#include<vector>
#include<queue>
#include<cstring>
#define p pair<int,int>
using namespace std;

int dx[] = {0,0,1,-1};
int dy[] = {1,-1,0,0};

int map[12][15];
int n,m;
int ans;

struct Node{
    int x;
    int y;
    int value;
    Node(int a,int b, int c): x(a), y(b), value(c){};
};


bool inRange(int x, int y){
    if(x < 0 || x >= n || y < 0 || y >= m)
        return false;
    return true;
}

void dfs(int shots){
    if( shots == 0 ){
        int _ans = 0;
        for(int x=0; x<n; x++){
            for(int y=0; y<m; y++){
                if(map[x][y] != 0)
                    _ans++;
            }
        }
        ans = ans < _ans ? ans : _ans;
        return ;
    }
    
    int init_map[12][15];
    
    for(int i=0; i<n; i++) for(int j=0; j<m; j++) init_map[i][j] = map[i][j];
    for(int x=0; x<m; x++){
        queue<Node> q;
        for(int y=0; y<n; y++){
            if(map[x][y] != 0 ){
                q.push( Node(x,y, map[x][y]) );
                map[x][y] = 0;
                break;
            }
        }
     
        while (! q.empty()) {
            int x = q.front().x;
            int y = q.front().y;
            int value = q.front().value;
            q.pop();
            
            for(int d=0; d<4; d++){
                int nx = x;
                int ny = y;
                for(int j=0; j<value-1; j++){
                    nx = nx + dx[d];
                    ny = ny + dy[d];
                    if(!inRange(nx, ny)) continue;
                    if( map[nx][ny] != 0) q.push(Node(nx,ny, map[nx][ny]));
                    map[nx][ny] = 0;
                }
            }
        
        }
        
        for(int i=0; i<m; i++){
            queue<int> q;
            
            for(int j=n-1; j>=0; j--){
                if(map[j][i] != 0)
                    q.push(map[j][i]);
            } 
            
            
            for(int k=0; k<15; k++)
                q.push(0);

            for(int j=n-1; j>=0; j--){
                map[j][i] = q.front();
                q.pop();
            }
        } 

        dfs(shots - 1);
        for(int i=0; i<n; i++) for(int j=0; j<m; j++) map[i][j] = init_map[i][j];
    }
}

int main(){
    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
    
    int TC;
    cin >> TC;
    
    for(int tc=1; tc<=TC; tc++){
        memset(map,0,sizeof(map));
        ans = 1e9;
        int shots;
        cin >> shots >> m >> n ;
        for(int i=0; i<n; i++){
            for(int j=0; j<m; j++){
                cin >> map[i][j];
            }
        }
        dfs(shots);
        cout << "#" << tc << " " << ans << '\n';
    }
    return 0;
}
```