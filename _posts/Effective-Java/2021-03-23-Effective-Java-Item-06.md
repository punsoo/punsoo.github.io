---
defaults:
  - scope:
      path: ""
      type: posts
    values:
      layout: single
      author_profile: true
      comments: true
      share: true
      related: true

title: "Effective Java Item 06"
excerpt: "불필요한 객체 생성을 피하라"
toc: true
toc_sticky: true
toc_label: "목차"
categories:
  - Effective Java
tags:
  - [Effective Java, 오토 박싱, 정적 팩터리 메소드]
date: 2021-03-23
last_modified_at: 2021-03-23
---

# 불필요한 객체 생성을 피하라

## 1️⃣ 불변 객체는 언제든 재사용할 수 있다.  

```java
String s = new String("bikini");
```
이 문장은 실행될 때마다 String 인스턴스를 새로 만든다 (완전히 쓸데없는 행위다)
```java
String s = "bikini";
```
이 코드는 하나의 String 인스턴스를 사용한다.  
이 방식을 사용한다면 같은 가상 머신 안에서 이와 똑같은 문자열 리터럴을 사용하는 모든 코드가 같은 객체를 
재사용함이 보장된다.

## 2️⃣ 정적 팩터리 메소드를 사용해 불필요한 객체 생성을 피할 수 있다.  

*ex) Boolean(String) 생성자 대신 Boolean.valueOf(String)*
불변 객체가 아닌 가벽 객체라 해도 사용 중에 변경되지 않을 것임을 안다면 재사용할 수 있다.

## 3️⃣ 생성 비용이 비싼 객체는 캐싱하여 재사용하자.

정규표현식용 Pattern 인스턴스는 정규표현식에 해당하는 유한 상태 머신을 만들기 때문에 인스턴스 생성 비용이 높다.  
성능을 개선하려면 필요한 정규표현식을 표현하는 Pattern 인스턴스를 클래스 초기화 과정에서 직접 생성해 캐싱해두자.

이 때 지연 초기화(lazy intialization)로 불필요한 초기화를 없앨 수 있다.  
하지만 지연 초기화는 코드를 복잡하게 만드는데 성능은 크게 개선되지 않을 때가 많아 권장되지 않는다.

## 4️⃣ 어댑터(뷰)는 뒷단 객체 하나당 하나씩만 만들어지면 충분하다.

에를 들자면, Map 인터페이스의 keySet메서드는 Set 인스턴스 (어댑터,뷰)를 반환한다.  
이 때 Set 인스턴스들은 똑같은 Map 인스턴스를 대변하기 때문에 다른 객체일 필요가 없다.

## 5️⃣ 박싱된 기본 타입보다는 기본 타입을 사용하고, 의도치 않은 오토박싱이 숨어들지 않도록 하자.

오토박싱은 기본 타입과 그에 대응하는 박싱된 기본 타입의 (의미상) 구분을 흐려주지만, 성능면에서 차이가 난다.  

```java
private static long sum(){
  Long sum = 0L;	
  for(long i =0; i <= Integer.MAX_VALUE; i++){
    sum += i;	// 불필요한 Long 인스턴스가 만들어진다.
  }
  return sum;
}
```

위 코드는 매우 느리다. 불필요한 Long 인스턴스가 만들어진다.

## 6️⃣ 오해하지는 말자.

프로그램의 명확성, 간결성, 기능을 위해서 객체를 추가로 생성하는 것이라면 일반적으로 좋은 일이다.  
객체 생성을 피하고자 객체 풀(pool)을 만들지도 말자. 데이터베이스 연결 같은 경우에는 생성 비용이 워낙 
비싸니 재사용하는 편이 낫다. 하지만 일반적으로는 자체 객체 풀은 코드를 헷갈리게 만들고 메모리 사용량을 
늘리고 성능을 떨어뜨린다. 최신 JVM의 가비지 컬렉터는 상당히 잘 최적화되어서 가벼운 객체용을 다룰 때는 
직접 만든 객체 풀보다 훨씬 빠르다.  
방어적 복사가 필요한 경우까지 객체를 재사용하지는 않아야한다.  
방어적 복사에 실패해서 생기는 버그와 보안 구멍으로 인한 피해가 불필요한 객체 생성으로 인한 성능 피해보다 
훨씬 크다는 것을 기억하자.